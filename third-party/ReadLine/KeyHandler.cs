// <autogenerated />

using Internal.ReadLine.Abstractions;

using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;

namespace Internal.ReadLine
{
    internal class KeyHandler
    {
        private readonly StringBuilder _text;
        private readonly List<string> _history;
        private readonly Dictionary<string, Func<Task>> _keyActions;
        private readonly IConsole _console;
        private int _cursorPos;
        private int _cursorLimit;
        private int _historyIndex;
        private ConsoleKeyInfo _keyInfo;
        private string[] _completions;
        private int _completionStart;
        private int _completionsIndex;

        private bool IsStartOfLine() => _cursorPos == 0;

        private bool IsEndOfLine() => _cursorPos == _cursorLimit;

        private bool IsStartOfBuffer() => _console.CursorLeft == 0;

        private bool IsEndOfBuffer() => _console.CursorLeft == _console.BufferWidth - 1;
        private bool IsInAutoCompleteMode() => _completions != null;

        private Task MoveCursorLeft()
        {
            if (IsStartOfLine())
            {
                return Task.CompletedTask;
            }

            if (IsStartOfBuffer())
            {
                _console.SetCursorPosition(_console.BufferWidth - 1, _console.CursorTop - 1);
            }
            else
            {
                _console.SetCursorPosition(_console.CursorLeft - 1, _console.CursorTop);
            }

            _cursorPos--;
            return Task.CompletedTask;
        }

        private async Task MoveCursorHome()
        {
            while (!IsStartOfLine())
            {
                await MoveCursorLeft().ConfigureAwait(false);
            }
        }

        private string BuildKeyInput()
        {
            return (_keyInfo.Modifiers != ConsoleModifiers.Control && _keyInfo.Modifiers != ConsoleModifiers.Shift) ?
                _keyInfo.Key.ToString() : _keyInfo.Modifiers.ToString() + _keyInfo.Key.ToString();
        }

        private Task MoveCursorRight()
        {
            if (IsEndOfLine())
            {
                return Task.CompletedTask;
            }

            if (IsEndOfBuffer())
            {
                _console.SetCursorPosition(0, _console.CursorTop + 1);
            }
            else
            {
                _console.SetCursorPosition(_console.CursorLeft + 1, _console.CursorTop);
            }

            _cursorPos++;

            return Task.CompletedTask;
        }

        private async Task MoveCursorEnd()
        {
            while (!IsEndOfLine())
            {
                await MoveCursorRight().ConfigureAwait(false);
            }
        }

        private async Task ClearLine()
        {
            await MoveCursorEnd().ConfigureAwait(false);
            while (!IsStartOfLine())
            {
                await Backspace().ConfigureAwait(false);
            }
        }

        private async Task WriteNewString(string str)
        {
            await ClearLine().ConfigureAwait(false);
            foreach (var character in str)
            {
                WriteChar(character);
            }
        }

        private void WriteString(string str)
        {
            foreach (var character in str)
            {
                WriteChar(character);
            }
        }

        private void WriteChar() => WriteChar(_keyInfo.KeyChar);

        private void WriteChar(char c)
        {
            if (IsEndOfLine())
            {
                _text.Append(c);
                _console.Write(c.ToString());
                _cursorPos++;
            }
            else
            {
                var left = _console.CursorLeft;
                var top = _console.CursorTop;
                var str = _text.ToString().Substring(_cursorPos);
                _text.Insert(_cursorPos, c);
                _console.Write(c.ToString() + str);
                _console.SetCursorPosition(left, top);
                MoveCursorRight();
            }

            _cursorLimit++;
        }

        private async Task Backspace()
        {
            if (IsStartOfLine())
            {
                return;
            }

            await MoveCursorLeft().ConfigureAwait(false);
            var index = _cursorPos;
            _text.Remove(index, 1);
            var replacement = _text.ToString().Substring(index);
            var left = _console.CursorLeft;
            var top = _console.CursorTop;
            _console.Write($"{replacement} ");
            _console.SetCursorPosition(left, top);
            _cursorLimit--;
        }

        private Task Delete()
        {
            if (IsEndOfLine())
            {
                return Task.CompletedTask;
            }

            var index = _cursorPos;
            _text.Remove(index, 1);
            var replacement = _text.ToString().Substring(index);
            var left = _console.CursorLeft;
            var top = _console.CursorTop;
            _console.Write($"{replacement} ");
            _console.SetCursorPosition(left, top);
            _cursorLimit--;
            return Task.CompletedTask;
        }

        private async Task TransposeChars()
        {
            // local helper functions
            bool AlmostEndOfLine() => (_cursorLimit - _cursorPos) == 1;
            static int IncrementIf(Func<bool> expression, int index) =>  expression() ? index + 1 : index;
            static int DecrementIf(Func<bool> expression, int index) => expression() ? index - 1 : index;

            if (IsStartOfLine()) { return; }

            var firstIdx = DecrementIf(IsEndOfLine, _cursorPos - 1);
            var secondIdx = DecrementIf(IsEndOfLine, _cursorPos);

            var secondChar = _text[secondIdx];
            _text[secondIdx] = _text[firstIdx];
            _text[firstIdx] = secondChar;

            var left = IncrementIf(AlmostEndOfLine, _console.CursorLeft);
            var cursorPosition = IncrementIf(AlmostEndOfLine, _cursorPos);

            await WriteNewString(_text.ToString()).ConfigureAwait(false);

            _console.SetCursorPosition(left, _console.CursorTop);
            _cursorPos = cursorPosition;

            await MoveCursorRight().ConfigureAwait(false);
        }

        private async Task StartAutoComplete()
        {
            while (_cursorPos > _completionStart)
            {
                await Backspace().ConfigureAwait(false);
            }

            _completionsIndex = 0;

            WriteString(_completions[_completionsIndex]);
        }

        private async Task NextAutoComplete()
        {
            while (_cursorPos > _completionStart)
            {
                await Backspace().ConfigureAwait(false);
            }

            _completionsIndex++;

            if (_completionsIndex == _completions.Length)
            {
                _completionsIndex = 0;
            }

            WriteString(_completions[_completionsIndex]);
        }

        private async Task PreviousAutoComplete()
        {
            while (_cursorPos > _completionStart)
            {
                await Backspace().ConfigureAwait(false);
            }

            _completionsIndex--;

            if (_completionsIndex == -1)
            {
                _completionsIndex = _completions.Length - 1;
            }

            WriteString(_completions[_completionsIndex]);
        }

        private Task PrevHistory()
        {
            if (_historyIndex > 0)
            {
                _historyIndex--;
                return WriteNewString(_history[_historyIndex]);
            }

            return Task.CompletedTask;
        }

        private Task NextHistory()
        {
            if (_historyIndex < _history.Count)
            {
                _historyIndex++;
                if (_historyIndex == _history.Count)
                {
                    return ClearLine();
                }

                return WriteNewString(_history[_historyIndex]);
            }

            return Task.CompletedTask;
        }

        private void ResetAutoComplete()
        {
            _completions = null;
            _completionsIndex = 0;
        }

        public string Text => _text.ToString();

        public KeyHandler(IConsole console, List<string> history, IAutoCompleteHandler autoCompleteHandler)
        {
            _console = console;

            _history = history ?? new List<string>();
            _historyIndex = _history.Count;
            _text = new StringBuilder();
            _keyActions = new Dictionary<string, Func<Task>>();

            _keyActions["LeftArrow"] = MoveCursorLeft;
            _keyActions["Home"] = MoveCursorHome;
            _keyActions["End"] = MoveCursorEnd;
            _keyActions["ControlA"] = MoveCursorHome;
            _keyActions["ControlB"] = MoveCursorLeft;
            _keyActions["RightArrow"] = MoveCursorRight;
            _keyActions["ControlF"] = MoveCursorRight;
            _keyActions["ControlE"] = MoveCursorEnd;
            _keyActions["Backspace"] = Backspace;
            _keyActions["Delete"] = Delete;
            _keyActions["ControlD"] = Delete;
            _keyActions["ControlH"] = Backspace;
            _keyActions["ControlL"] = ClearLine;
            _keyActions["Escape"] = ClearLine;
            _keyActions["UpArrow"] = PrevHistory;
            _keyActions["ControlP"] = PrevHistory;
            _keyActions["DownArrow"] = NextHistory;
            _keyActions["ControlN"] = NextHistory;
            _keyActions["ControlU"] = async () =>
            {
                while (!IsStartOfLine())
                {
                    await Backspace().ConfigureAwait(false);
                }
            };
            _keyActions["ControlK"] = async () =>
            {
                var pos = _cursorPos;
                await MoveCursorEnd().ConfigureAwait(false);
                while (_cursorPos > pos)
                {
                    await Backspace().ConfigureAwait(false);
                }
            };
            _keyActions["ControlW"] = async () =>
            {
                while (!IsStartOfLine() && _text[_cursorPos - 1] != ' ')
                {
                    await Backspace().ConfigureAwait(false);
                }
            };
            _keyActions["ControlT"] = TransposeChars;

            _keyActions["Tab"] = async () =>
            {
                if (IsInAutoCompleteMode())
                {
                    await NextAutoComplete().ConfigureAwait(false);
                }
                else
                {
                    if (autoCompleteHandler == null || !IsEndOfLine())
                    {
                        return;
                    }

                    var text = _text.ToString();

                    _completionStart = text.LastIndexOfAny(autoCompleteHandler.Separators);
                    _completionStart = _completionStart == -1 ? 0 : _completionStart + 1;

                    _completions = await autoCompleteHandler.GetSuggestionsAsync(text, _completionStart)
                       .ConfigureAwait(false);
                    _completions = _completions?.Length == 0 ? null : _completions;

                    if (_completions == null)
                    {
                        return;
                    }

                    await StartAutoComplete().ConfigureAwait(false);
                }
            };

            _keyActions["ShiftTab"] = () =>
            {
                if (IsInAutoCompleteMode())
                {
                    return PreviousAutoComplete();
                }

                return Task.CompletedTask;
            };
        }

        public Task Handle(ConsoleKeyInfo keyInfo)
        {
            _keyInfo = keyInfo;

            // If in auto complete mode and Tab wasn't pressed
            if (IsInAutoCompleteMode() && _keyInfo.Key != ConsoleKey.Tab)
            {
                ResetAutoComplete();
            }

            if (_keyActions.TryGetValue(BuildKeyInput(), out var action))
            {
                return action();
            }

            WriteChar();

            return Task.CompletedTask;
        }
    }
}
